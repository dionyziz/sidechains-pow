\section{Introduction}

Bitcoin~\cite{bitcoin} has emerged as the most successful \emph{cryptocurrency}
in history. Its innovative technology has introduced \emph{blockchains}, a
cryptographically \emph{authenticated data
structure}~\cite{miller2014authenticated} in which monetary and other
\emph{transactions} are organized into \emph{blocks} which are then put in
order. To achieve \emph{consensus} about their order, a
\emph{proof-of-work}~\cite{C:DwoNao92} is included in each block. Transactions
moving value within such blockchains have been proven to be secure in that
consensus is eventually achieved \cite{EC:GarKiaLeo15}\cite{C:GarKiaLeo17},
solving the long-standing \emph{anonymous byzantine agreement} problem in the
literature of distributed computing~\cite{miller2014anonymous}.

Ethereum~\cite{buterin} extends Bitcoin's functionality and introduces the
ability to write arbitrary code to be run on the blockchain through
Turing-complete \emph{smart contracts} written in programming languages such as
Solidity. These smart contracts execute autonomously on blockchains.
While the Ethereum Virtual Machine~\cite{wood} executing such contracts allows
for Turing-completeness, the smart contracts are generally confined to access
data only within the blockchain itself, such as previous transactions and
blocks. Access to external world data requires some third party or group of
third parties to vouch for the validity of the data~\cite{CCS:ZCCJS16},
essentially mandating the need for the trusted third party or trusted group of
third parties.

Sidechains~\cite{sidechains} are a mechanism for cross-chain communication in
blockchains. They allow the smart contracts on one blockchain to receive and
react to \textit{events} that take place on another blockchain without the need
of a trusted third party.

\noindent\textbf{Our contributions. } In this paper, we introduce the first
trustless construction for proof-of-work sidechains. We describe how to build
sidechains that support \emph{two-way pegging} and in which an asset can be
moved from one blockchain to another while retaining its nature. We illustrate
how to move assets by providing a high-level construction for Turing-complete
blockchains such as Ethereum in Solidity, and we prove our construction is
secure under the assumption that the interoperating blockchains are secure
individually. To our knowledge, we are the first to provide such a construction
in full and prove its security. Our construction works across a broad range of
blockchains requiring only two underlying properties. First, that the
\emph{source} blockchain is a proof-of-work blockchain supporting
Non-Interactive Proofs of Proof-of-Work (NIPoPoWs), a cryptographic primitive
which allows constructing succinct proofs \emph{about} events which occur in a
proof-of-work blockchain and which was recently introduced by Miller et
al.~\cite{nipopows}. Support for NIPoPoWs can be easily introduced to practically
any work-based cryptocurrency which uses a localized hash function to achieve
proof-of-work, such as SHA256 as used by Bitcoin, Bitcoin Cash, Litecoin or
ZCash. Second, that the \emph{target} blockchain is able to validate such proofs
by, for instance, being Turing-complete, such as, e.g., Ethereum or Ethereum
Classic. Any blockchain supporting advanced smart contracts is sufficient.

We provide a smart contract skeleton for how to build such pegs.

\noindent\textbf{Related work. }
Sidechains were introduced as a Bitcoin upgrade mechanism by Back et
al.~\cite{sidechains}. The upgrade mechanism proposed introducing new
\emph{child} blockchains with a new genesis block, which implement a new version
of the protocol. The asset handled by such sidechains is the same as the asset
of the mainchain and can be moved between the mainchain and the sidechain
through \emph{2-way pegging}. The \emph{firewall} property was also introduced
in their work, in that, a macroeconomic failure in the sidechain, such as a
security problem which could allow the violation of money supply policies, will
not impact the mainchain. No security definitions or construction of the
protocol were provided in this paper. However, their paper hints at the need for
``\emph{secure SPV proofs}'' (Appendix B) in future work.

We use the word \emph{sidechain} in a more general notion than in the work by
Back et al. Our sidechains allow communication between \emph{stand
alone} blockchains. In our work, a blockchain is a sidechain of another chain if
it can detect and react to events on that chain.

There have been several attempts to create various cross-chain transfer
mechanisms. Polkadot~\cite{wood2016polkadot},
Cosmos~\cite{buchman2016tendermint}, Blockstream's Liquid and Interledger
attempt to realize such cross-chain transfers; however, their validation relies
on a trusted committees or federations or is underspecified.

Drivechains are a trustless sidechain proposal, but they require miners of both
the sending and the receiving chain to be aware of both networks and to maintain
both blockchain headers fully. This can prove inefficient when a large number of
sidechains wish to be connected to a particular mainchain, as the drivechain
maintainers will need to be updated by a soft fork to add support for all of
them separately and they would also need to maintain the entirety of the block
headers in each of them. In our scheme, miners of both chains can remain fully
unaware of the existence of other chains and remain connected only to one
network.

BTCRelay is a mechanism that allows relaying information from Bitcoin to
Ethereum specifically. The Ethereum and Bitcoin miners do not need to maintain
anything else than their local chain and can remain connected to their
respective chain network only. Unlike our proposal, however, BTCRelay requires
the retransmission of the entirety of the source blockchain headers into the
target blockchain as smart contract parameters, an endeavour which consumes data
linear in the side of the source blockchain. Our proposal instead only requires
submitting parameters logarithmic in size of the source blockchain. This is
inherited by the \emph{succinctness} property of the NIPoPoW scheme that we use,
which gives rise to our \emph{sidechain correctness} property.
