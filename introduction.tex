\section{Introduction}

Bitcoin~\cite{bitcoin} has emerged as the most successful \emph{cryptocurrency}
in history. Its innovative technology has introduced \emph{blockchains}, a
cryptographically \emph{authenticated data
structure}~\cite{miller2014authenticated} in which monetary and other
\emph{transactions} are organized into \emph{blocks} which are then put in
order. To achieve \emph{consensus} about their order, a
\emph{proof-of-work}~\cite{C:DwoNao92} is included in each block. Transactions
moving value within such blockchains have been proven to be secure in that
consensus is eventually achieved \cite{EC:GarKiaLeo15}\cite{C:GarKiaLeo17},
solving the long-standing \emph{anonymous byzantine agreement} problem in the
literature of distributed computing~\cite{miller2014anonymous}.

Ethereum~\cite{buterin} extends Bitcoin's functionality and introduces the
ability to write arbitrary code to be run on the blockchain through
Turing-complete \emph{smart contracts} written in programming languages such as
Solidity. These smart contracts execute autonomously on blockchains.
While the Ethereum Virtual Machine~\cite{wood} executing such contracts allows
for Turing-completeness, the smart contracts are generally confined to access
data only within the blockchain itself, such as previous transactions and
blocks. Access to external world data requires some third party or group of
third parties to vouch for the validity of the data~\cite{CCS:ZCCJS16},
essentially mandating the need for the trusted third party or trusted group of
third parties.

Sidechains~\cite{sidechains} are a mechanism for cross-chain communication in
blockchains. They allow the smart contracts on one blockchain to receive and
react to \textit{events} that take place on another blockchain without the need
of a trusted third party.

\noindent\textbf{Our contributions. } In this paper, we introduce the first
practical construction for proof-of-work sidechains. We describe how to build
sidechains that support \emph{two-way pegging} and in which an asset can be
moved from one blockchain to another while retaining its nature. We illustrate
how to move assets by providing a high-level construction for Turing-complete
blockchains such as Ethereum in Solidity, and we prove our construction is
secure under the assumption that the interoperating blockchains are secure
individually. To our knowledge, we are the first to provide such a construction
in full and prove its security. Our construction works across a broad range of
blockchains requiring only two underlying properties. First, that the
\emph{source} blockchain is a proof-of-work blockchain supporting
Non-Interactive Proofs of Proof-of-Work (NIPoPoWs), a cryptographic primitive
which allows constructing succinct proofs \emph{about} events which occur in a
proof-of-work blockchain and which was recently introduced by Miller et
al.~\cite{nipopows}. Support for NIPoPoWs can be easily introduced to practically
any work-based cryptocurrency which uses a localized hash function to achieve
proof-of-work, such as SHA256 as used by Bitcoin, Bitcoin Cash, Litecoin or
ZCash. Second, that the \emph{target} blockchain is able to validate such proofs
by, for instance, being Turing-complete, such as, e.g., Ethereum or Ethereum
Classic. Any blockchain supporting advanced smart contracts is sufficient.

We provide a smart contract skeleton for how to build such pegs.

\noindent\textbf{Related work. }
Sidechains were introduced as a concept by Back et al.~\cite{sidechains}. In
their original introduction, they were presented as a mechanism for upgrading
the Bitcoin blockchain. The upgrade mechanism proposed introducing new
\emph{child} blockchains with a new genesis block, called
\emph{sidechains} in this context, which act as a new version proposed for the
protocol and which can have assets moved between them and their \emph{parent}
blockchain, called \emph{mainchain} in this context. The asset handled by such
sidechains is the same as the asset of the mainchain. Assets moved to the
sidechain can be returned to the mainchain through \emph{2-way pegging}. This
allows for upgrades, avoiding the need for hard and soft forks, as stakeholders
can opt-in by moving their assets to the new chain. The \emph{firewall}
property was also introduced in their work, in that, a macroeconomic failure in
the sidechain, such as a security problem which could allow the violation of
money supply policies, will not impact the mainchain. While these concepts were
introduced as high-level ideas, no security definitions or instantiation of the
protocol were provided. More importantly, a way to securely prove facts about
the sidechain on the mainchain was not presented, as so-called \emph{secure SPV
proofs} such as NIPoPoWs had not been invented at the time. However, the paper
by Back et al. does hint at the direction of using a NIPoPoWs-like data
structure for construction sidechains (Appendix B), a construction proposed at a
high level but never made concrete.

We use the word \emph{sidechain} in a different notion than in that work in that
our sidechains allow communication between potentially \emph{stand alone}
blockchains and that two blockchains could both be a sidechain of one another.
In our work, a blockchain is a sidechain of another chain if it can detect and
react to events on that chain. Under that definition, a blockchain is a
sidechain if it simply has the ability to react to events that have occurred on
a remote chain.

There have been several attempts to create various cross-chain transfer
mechanisms. Polkadot~\cite{wood2016polkadot},
Cosmos~\cite{buchman2016tendermint}, Blockstream's Liquid and Interledger
attempt to realize such cross-chain transfers; however, their validation relies
on a Byzantine Fault Tolerant construction which does not allow for a fully
trustless setting. More specifically, their implementation relies on
\emph{trusted committees} to attest to the validity of cross-chain claims in
which the majority of participants, by count, are assumed to be honest. Our
scheme does not require such trust.

Drivechains are a trustless sidechain proposal, but they require miners of both
the sending and the receiving chain to be aware of both networks and to maintain
both blockchain headers fully. This can prove inefficient when a large number of
sidechains wish to be connected to a particular mainchain, as the drivechain
maintainers will need to be updated by a soft fork to add support for all of
them separately and they would also need to maintain the entirety of the block
headers in each of them. In our scheme, miners of both chains can remain fully
unaware of the existence of other chains and remain connected only to one
network.

BTCRelay is a mechanism that allows relaying information from Bitcoin to
Ethereum specifically. The Ethereum and Bitcoin miners do not need to maintain
anything else than their local chain and can remain connected to their
respective chain network only. Unlike our proposal, however, BTCRelay requires
the retransmission of the entirety of the source blockchain headers into the
target blockchain as smart contract parameters, an endeavour which consumes data
linear in the side of the source blockchain. Our proposal instead only requires
submitting parameters logarithmic in size of the source blockchain. This is
inherited by the \emph{succinctness} property of the NIPoPoW scheme that we use,
which gives rise to our \emph{sidechain correctness} property.
